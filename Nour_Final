import numpy as np
beacons = np.array([             # nodes of the walls
    [0, 0],
    [0, 100],
    [100, 100],
    [100, 0]
])

walls = np.array([                               # from which node to which we draw walls
    [beacons[0], beacons[1]],
    [beacons[1], beacons[2]],
    [beacons[2], beacons[3]],
    [beacons[3], beacons[0]]
])

print("beacons: ", beacons)

for i in range(0, 4):
    print("wall ", i, ": from",walls[i][0],"to ", walls[i][1])
    
angle=input("please enter the angle of movement: ")

pi = np.array([20, 20, int(angle)])      # this is the inicial position of the robot (x, y, teta)

print("initial position of the robot: ", pi)

botsize = 10
velocity = 10

movement = np.array([
    velocity * np.cos(np.deg2rad(pi[2])),       # x changes according to the cos(teta)
    velocity * np.sin(np.deg2rad(pi[2])),       # y changes according to the sin(teta)
    0                                # teta does not change
])
po = movement + pi  # output position
# now, we want to make it move straight forward, so this depends of teta (the angle of our robot)
while(1):
    if po[0]<=beacons[1][0] or po[0]<=beacons[0][0]:
        po[0]= botsize/2
        print("I've crashed the wall at point",po)
        break
    elif po[0]>=beacons[2][0] or po[0]>=beacons[3][0]:
        po[0]= 100-(botsize/2)
        po[0]=round(po[0],1)
        print("I've crashed the wall at point",po)
        break
    elif po[1]>=beacons[1][1] or po[1]>=beacons[2][1]:
        po[1]= 100-(botsize/2)
        po[1]=round(po[1],1)
        print("I've crashed the wall at point", po)
        break
    elif  po[1]<=beacons[0][1] or po[1]<=beacons[3][1]:
        po[1]= botsize/2
        print("I've crashed the wall at point", po)
        break
    else:
        po += movement     # output position
        po[0]=round(po[0],1)
        po[1]=round(po[1],1)

        print("next position: ", po)


# this makes the robot go straight forward, do this until you find a wall
# each time you calculate a new position, you must check it is correct (the circle of center po and radius botsize/2 does not touch ANY wall)
# use for loops and wall[i][0] for x and wall[i][1] for y, of each wall



